<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://jujpenabe.github.io/style.css">
    <link rel="stylesheet" href="https://jujpenabe.github.io/color/blue-auto.css">

        <link rel="stylesheet" href="https://jujpenabe.github.io/color/background_auto.css">
    
    <link rel="stylesheet" href="https://jujpenabe.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://jujpenabe.github.io/blog/p5retainedmodevsthreejs/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="">
    <meta property="twitter:domain" content="jujpenabe.github.io">
    <meta property="twitter:url" content="https://jujpenabe.github.io/blog/p5retainedmodevsthreejs/">

    <link rel="stylesheet" href="/css/custom.css">
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://jujpenabe.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Web 3D Gaussian Splatting
                        
                    </div>
                </a>
            </div>
        </div>

        
        <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://jujpenabe.github.io/blog">blog</a></li>
            
                <li><a href="https://jujpenabe.github.io/pages/archive">archive</a></li>
            
                <li><a href="https://jujpenabe.github.io/pages/about">about me</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/p5retainedmodevsthreejs/">P5 retained mode vs Threejs</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-02-10
        </span>

    </div>

    

        <div class="post-content">
            <table class="header">
 <tr>
    <td colspan="2" rowspan="2" class="width-auto">
      <h2 class="title">P5 retained mode vs Three.js</h2>
      <span class="subtitle">A WebGL benchmark of popular 3D web frameworks</span>
    </td>
    <th>Version</th>
    <td class="width-min">v0.1.0</td>
  </tr>
  <tr>
    <th>Updated</th>
    <td class="width-min"><time style="white-space: pre;">2025-03-10</time></td>
  </tr>
  <tr>
    <th class="width-min">Author</th>
    <td class="width-auto"><a href="https://mainpage.me/catblue44"><cite> Juan José Peña Becerra
</cite></a></td>
    <th class="width-min">License</th>
    <td>MIT</td>
  </tr>
</table>
<h4 id="methodology">METHODOLOGY</h4>
<p>To compare different rendering methods, a series of tests were conducted to evaluate performance in terms of rendering speed and responsiveness. Each test instantiated the same point cloud, represented as ellipses with 32 points by default. The only difference between the experiments was the rendering approach used:
<ul>
<li>p5.js - Immediate Mode: Each frame, all points are redrawn from scratch using procedural rendering.</li>
<li>p5.js - Retained Mode: Points are stored as objects and only updated when necessary, reducing redundant computations.</li>
<li>Three.js - BufferGeometry: Points are stored in a single geometry buffer, minimizing draw calls and improving performance compared to immediate mode.</li>
<li>Three.js - InstancedMesh: Instead of creating individual objects, a single mesh instance is reused multiple times, further optimizing rendering by leveraging GPU instancing.</li>
</ul>
<p>Each test was executed under the same conditions, measuring frame rate, CPU usage, and responsiveness to user interaction.</p>
</p>Explore the interactive sketches for each tool using the links below:
<hr>
<div class="button-container" style="display: flex; gap: 10px; justify-content: center; align-items: center;">
    <a href="https://editor.p5js.org/jujpenabe/full/-HC2R1oYt" target="_blank">
      <button style="margin: 0;">P5 immediate mode</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/PzAJrh2a3" target="_blank">
      <button style="margin: 0;">P5 retained mode</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/uaWCrVlPH" target="_blank">
      <button style="margin: 0;">Three.js Buffer geometry</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/F10ioEqie" target="_blank">
      <button style="margin: 0;">Three.js Instanced Mesh</button>
    </a>
</div>
<hr>
<h4 id="p5-js-immediate-vs-retained-mode">P5.JS IMMEDIATE VS RETAINED MODE</h4>
<p>P5.js API provides two modes for rendering:  <a href="https://p5js.org/contribute/webgl_mode_architecture/#rendering-shapes-immediate-and-retained-modes." target="_blank">Immediate and Retained Modes</a>.</p>
<p>p5.js - Immediate Mode: In this approach, each frame is redrawn from scratch, meaning all shapes are re-rendered in every rendering cycle. This method is straightforward to implement but can become inefficient as scene complexity increases.</p>
<p>In the draw() method we use beginShape and endShape to create a series of vertices that define the shape of the object.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#65737e;">// Using immediate mode
</span><span style="color:#8fa1b3;">beginShape</span><span>(</span><span style="color:#bf616a;">TRIANGLE_FAN</span><span>);
</span><span>
</span><span style="color:#65737e;">// Center point
</span><span style="color:#8fa1b3;">vertex</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span style="color:#65737e;">// Draw points around ellipse
</span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">segments </span><span>= </span><span style="color:#d08770;">32</span><span>;
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">angle </span><span>= </span><span style="color:#8fa1b3;">map</span><span>(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">segments</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">TWO_PI</span><span>);
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">x </span><span>= </span><span style="color:#8fa1b3;">cos</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">20</span><span>;
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">y </span><span>= </span><span style="color:#8fa1b3;">sin</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">10</span><span>;
</span><span>  </span><span style="color:#8fa1b3;">vertex</span><span>(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>}
</span><span>
</span><span style="color:#8fa1b3;">endShape</span><span>();
</span></code></pre>
<p>p5.js - Retained Mode using p5.Geometry: While p5.js doesn't offer a native retained mode, you can simulate this behavior using the p5.Geometry class. This class allows you to create and store complex 3D geometries that can be rendered more efficiently. By constructing the geometry once and then drawing it as needed, you reduce redundant drawing operations, enhancing performance in complex scenes.</p>
<p>In the setup() method, we create a p5.Geometry object and store it in a variable called <code>ellipseGeom</code>.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">ellipseGeom</span><span>;
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">setup</span><span>() {
</span><span>
</span><span style="color:#65737e;">// Rest of setup() code
</span><span>
</span><span style="color:#65737e;">// Create retained mode geometry (just once)
</span><span>  </span><span style="color:#bf616a;">ellipseGeom </span><span>= </span><span style="color:#8fa1b3;">buildEllipseGeometry</span><span>();
</span><span>}
</span></code></pre>
<p>We build the geometry similar to how we build a shape in immediate mode. and return it as a p5.Geometry object.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">buildEllipseGeometry</span><span>() {
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">ellipse </span><span>= new p5.Geometry();
</span><span>
</span><span>  </span><span style="color:#65737e;">// Center point
</span><span>  </span><span style="color:#bf616a;">ellipse</span><span>.</span><span style="color:#bf616a;">vertices</span><span>.</span><span style="color:#96b5b4;">push</span><span>(new p5.Vector(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>));
</span><span>
</span><span>  </span><span style="color:#65737e;">// Draw points around ellipse
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">segments </span><span>= </span><span style="color:#d08770;">32</span><span>;
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">angle </span><span>= </span><span style="color:#8fa1b3;">map</span><span>(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">segments</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">TWO_PI</span><span>);
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">x </span><span>= </span><span style="color:#8fa1b3;">cos</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">20</span><span>;
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">y </span><span>= </span><span style="color:#8fa1b3;">sin</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#bf616a;">geometry</span><span>.</span><span style="color:#bf616a;">vertices</span><span>.</span><span style="color:#96b5b4;">push</span><span>(new p5.Vector(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#d08770;">0</span><span>));
</span><span>  }
</span><span>  
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>    </span><span style="color:#bf616a;">ellipse</span><span>.</span><span style="color:#bf616a;">faces</span><span>.</span><span style="color:#96b5b4;">push</span><span>([</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#bf616a;">i </span><span>+ </span><span style="color:#d08770;">1</span><span>]);
</span><span>  }
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">ellipse</span><span>;
</span><span>}
</span></code></pre>
<p>In the draw() method, we use the p5.Geometry object to draw the ellipse.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">draw</span><span>() {
</span><span>  </span><span style="color:#8fa1b3;">background</span><span>(</span><span style="color:#d08770;">0</span><span>);
</span><span>  
</span><span>  </span><span style="color:#65737e;">// Draw the ellipse
</span><span>  </span><span style="color:#8fa1b3;">model</span><span>(</span><span style="color:#bf616a;">ellipseGeom</span><span>);
</span><span>}
</span></code></pre>
<h4 id="benchmark-result">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/p5ImmediateVsRetained.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="threejs-buffer-geometry-vs-instanced-mesh">Threejs Buffer Geometry vs Instanced Mesh</h4>
<p>Three.js is more especialized in rendering 3D scenes. It offers a wide range of features and tools for creating and manipulating 3D objects. It provides different methods for rendering complex 3D scenes, including BufferGeometry, InstancedMesh, and InstancedBufferGeometry.</p>
<p>BufferGeometry is a low-level API that provides direct access to GPU buffers. It offers fine-grained control over vertex data and can be used to create complex 3D scenes.</p>
<h4 id="benchmark-result-1">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/threejsBufferGeometryVsInstancedMesh.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="p5-js-retained-mode-vs-three-js-buffer-geometry">P5.js retained mode vs three.js buffer geometry</h4>
<p>p5 retained mode uses p5.Geometry to simulate retained mode. You build the geometry once and reuse it for rendering, which reduces redundant drawing. However, it doesn't leverage full GPU-level optimizations.</p>
<p>A native, highly optimized solution that uses typed arrays to store vertex data. It offers better performance and fine-grained control for complex 3D scenes.</p>
<h4 id="benchmark-result-2">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/p5RetainedModeVSThreejsBufferGeometry.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="future-work">Future Work</h4>
<ul>
<li>investigate why p5.js's retained mode using p5.Geometry underperforms compared to Three.js's BufferGeometry. By benchmarking these methods, we can identify specific inefficiencies in the retained mode approach. Additionally, exploring alternative techniques such as instancedMesh and instancedBufferGeometry may offer further performance improvements. Evaluating frameworks that leverage WebGPU could also uncover new strategies for optimizing complex 3D rendering workflows.</li>
</ul>
<h4 id="conclusions">CONCLUSIONS</h4>
<p>
Each tool offers distinct advantages:
<ul class="incremental">
<li> P5.js is great for rapid prototyping and simpler projects. But it doesn't leverage full GPU-level optimizations.</li>
<li> Three.js strikes an effective balance, making it ideal for robust, production-ready WEB applications.</li>
</ul>
</p>

        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                    <hr />
                </div>
                <div class="pagination__buttons">
                    
                        <span class="button next">
                            <a href="https://jujpenabe.github.io/blog/webglvsp5vsthreejs/">
                                <span class="button__text">WEB 3D Point Clouds. Framework Comparison</span>&nbsp;
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    </div>
            </div>
        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user">&copy; 2025 Juan José Peña Becerra&nbsp;<b>Universidad Nacional de Colombia</b></div>
            </div>
    </footer>
    

</div>
</body>

</html>
