<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://jujpenabe.github.io/style.css">
    <link rel="stylesheet" href="https://jujpenabe.github.io/color/blue-auto.css">

        <link rel="stylesheet" href="https://jujpenabe.github.io/color/background_auto.css">
    
    <link rel="stylesheet" href="https://jujpenabe.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jujpenabe.github.io/blog/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="">
    <meta property="twitter:domain" content="jujpenabe.github.io">
    <meta property="twitter:url" content="https://jujpenabe.github.io/blog/">

    <link rel="stylesheet" href="/css/custom.css">
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://jujpenabe.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Web 3D Gaussian Splatting
                        
                    </div>
                </a>
            </div>
        </div>

        
        <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://jujpenabe.github.io/blog">blog</a></li>
            
                <li><a href="https://jujpenabe.github.io/pages/archive">archive</a></li>
            
                <li><a href="https://jujpenabe.github.io/pages/about">about me</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/todo/">Progress</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-03-08
        </span>

    </div>

    


                    <div class="post-content">
            <table>
<thead>
<tr>
<th class="width-auto">
Entry
</th>
<th class="width-auto">
Done
</th>
</tr>
</thead>
<tbody>
  <tr>
    <td>
      The Rosetta Code
    </td>
    <td>
        80%
    </td>
  </tr>
  <tr>
    <td>
      Web Tools Benchmark
    </td>
    <td>
        80%
    </td>
  </tr>
    <tr>
     <td> P5 2DGS Implementation</td>
     <td>
        0%
     </td>
   </tr>
   <tr>
      <td> Google Colab Training notebook</td>
      <td>
        0%
      </td>
    </tr>
  </tbody>
</table>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/rosettacode/">The Rosetta Code</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-03-07
        </span>

    </div>

    


                    <div class="post-content">
            <h4 id="the-rosetta-stone">The Rosetta Stone</h4>
<p>Just as the Rosetta Stone served as a bridge between ancient languages, enabling the deciphering of Egyptian hieroglyphs by providing parallel texts in Greek and Demotic scripts, modern 3D web frameworks like p5.js, Three.js, and WebGL act as intermediaries, translating complex graphics programming into more accessible forms for developers. These tools, built atop the WebGL API, have empowered developers to create intricate visual experiences on the web.</p>
<p><img src="https://sketchplanations.com/_next/image?url=https%3A%2F%2Fimages.prismic.io%2Fsketchplanations%2Fec6046c3-6ec9-46ae-9625-53f2c12376bc_129239825802.jpg%3Fauto%3Dcompress%2Cformat&amp;w=1080&amp;q=75" alt="rosetta stone" /></p>
<p>Similarly, the 3D Web frameworks described here can be "translated" between each other. Is importan to note that basically, most of the current 3D web frameworks are based on the WebGL API, which is a low-level API that exposes the OpenGL ES 3.0 API. So in a degree it is just a matter of preference to choose which framework to use. or at least it should be demonstrated in the next benchmark post. In this case we are comparing p5.JS, Three.js and WebGL.</p>
<h5 id="comparison-of-3d-point-cloud-development-webgl-p5-js-and-three-js">COMPARISON OF 3D POINT CLOUD DEVELOPMENT: WEBGL, P5.js, AND THREE.js</h5>
<p>In recent years, integrating 3D point clouds in web applications has become more accessible thanks to several JavaScript libraries and [APIs](https://en.wikipedia.org/wiki/API). This post compares three approaches—pure WebGL, P5.js, and Three.js—by examining their performance, ease of use, and suitability for interactive experiences.</p>
<h4 id="framework-overview">FRAMEWORK OVERVIEW</h4>
<h4 id="p5-js">P5.JS</h4>
<p><a href="https://github.com/processing/p5.js">p5.js</a> is a client-side JS platform that empowers artists, designers, students, and anyone to learn to code and express themselves creatively on the web. It is based on the core principles of Processing.</p>
<p>Is a higher-level library that simplifies graphics development. Although it’s primarily designed for 2D graphics, its 3D capabilities (including point clouds) make it a good choice for rapid prototyping and educational projects. However, handling very complex 3D data might be challenging.</p>
<p>P5 is actively developed and maintained by a vibrant community of developers, and its ecosystem of libraries and plugins is constantly evolving.</p>
<h4 id="three-js">THREE.JS</h4>
<p>Is one of the most popular 3D libraries for the web. It abstracts much of the low-level complexity of WebGL while still providing extensive functionality. This balance makes Three.js suitable for production-level applications, especially when integrating modern web technologies like VR or AR.</p>
<h4 id="pure-webgl">PURE WEBGL</h4>
<p>Provides low-level access to the GPU for 3D graphics, offering complete control over the rendering pipeline. This flexibility comes at the cost of increased complexity and the need for a strong background in 3D graphics programming.</p>
<p>WebGL is based on OpenGL ES, a low-level API for rendering 2D and 3D graphics on the web. It's a low-level API, which means that it's not as easy to use as higher-level APIs like Three.js or P5.js. The latest version of WebGL, WebGL 2.0 exposes the OpenGL ES 3.0 API.</p>
<h4 id="methodology">METHODOLOGY</h4>
<p>The experimet consist of the intantiaton of 3D point clouds in the browser using the Three.js, P5.js and WebGL libraries. the purpose is to check the accessibility of the three frameworks, their performance and ease of use to create interactive experiences.
</p>
<hr>
<p>You can test the interactive sketches for each tool using the links below:</p>
<div class="button-container" style="display: flex; gap: 10px; justify-content: center; align-items: center;">
    <a href="https://aijs-code-editor-user-content.web.app/Jt0mD7CW0uQHkOj4GzIUIHLkc4h2/Projects/P5_WebCloud/index.html" target="_blank">
      <button style="margin: 0;">P5.js</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/PzAJrh2a3" target="_blank">
      <button style="margin: 0;">Three.js</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/O9QSgf-IM" target="_blank">
      <button style="margin: 0;">WebGL</button>
    </a>
</div>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/theriseofwebgpu/">The Rise of WebGPU</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-03-05
        </span>

    </div>

    


                    <div class="post-content">
            <h4 id="the-rise-of-webgpu">The Rise of WebGPU</h4>
<p>As technology advances, there's a shift towards WebGPU—a modern web standard and API designed to harness the full potential of a device's graphics processing unit (GPU). Unlike WebGL, which is rooted in the older OpenGL ES, WebGPU draws inspiration from contemporary graphics APIs like Vulkan, Metal, and Direct3D 12. This evolution promises enhanced performance and more direct access to GPU capabilities.</p>
<h4 id="shaders-transitioning-from-glsl-to-wgsl">Shaders: Transitioning from GLSL to WGSL</h4>
<p>A significant aspect of this transition is the shift in shading languages. WebGL utilizes GLSL (OpenGL Shading Language), a language with a legacy spanning over two decades. In contrast, WebGPU introduces WGSL (WebGPU Shading Language). While WGSL is tailored for modern GPU architectures, its adoption has met with mixed reactions within the developer community.</p>
<h4 id="frameworks-adapting-to-change">Frameworks Adapting to Change</h4>
<p>Recognizing the evolving landscape, frameworks are adapting accordingly:</p>
<ul>
<li>
<p><strong>Three.js</strong>: To address concerns surrounding WGSL, the Three.js team is developing TSL (Three.js Shading Language). This proprietary shading language aims to offer developers a more intuitive and integrated experience within the Three.js ecosystem.</p>
</li>
<li>
<p><strong>p5.js</strong>: While primarily focused on 2D graphics, p5.js has ventured into 3D rendering using WebGL. The transition to WebGPU presents both challenges and opportunities for this framework, especially in balancing simplicity with advanced capabilities. In this context, <a href="https://q5js.org/home/"><strong>q5.js</strong></a> emerges as a noteworthy initiative. Inspired by p5.js and Processing, q5.js is a beginner-friendly graphics framework powered by WebGPU, optimized for interactive art, and compatible with popular addons like p5.sound and p5play. It offers a lightning-fast WebGPU renderer and aims to make creative coding more accessible.</p>
</li>
</ul>
<h4 id="looking-ahead">Looking Ahead</h4>
<p>The migration from WebGL to WebGPU signifies a pivotal shift in web graphics. Developers can anticipate more efficient rendering, broader access to GPU features, and the evolution of frameworks to accommodate these advancements. As these technologies mature, the web is poised to host richer and more immersive 3D experiences.</p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/webglvsp5vsthreejs/">WEB 3D Point Clouds. Framework Comparison</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-02-27
        </span>

    </div>

    


                    <div class="post-content">
            <table class="header">
 <tr>
    <td colspan="2" rowspan="2" class="width-auto">
      <h2 class="title">WebGL vs p5.js vs Three.js</h2>
      <span class="subtitle">WEB 3D Point Clouds. Framework Comparison</span>
    </td>
    <th>Version</th>
    <td class="width-min">v0.0.4</td>
  </tr>
  <tr>
    <th>Updated</th>
    <td class="width-min"><time style="white-space: pre;">2025-02-27</time></td>
  </tr>
  <tr>
    <th class="width-min">Author</th>
    <td class="width-auto"><a href="https://mainpage.me/catblue44"><cite> Juan José Peña Becerra
</cite></a></td>
    <th class="width-min">License</th>
    <td>MIT</td>
  </tr>
</table>
<h4 id="methodology">METHODOLOGY</h4>
<p>A series of tests were conducted to benchmark each tool, considering factors such as rendering speed and responsiveness. You can explore the interactive sketches for each tool using the links below:
</p>
<hr>
<div class="button-container" style="display: flex; gap: 10px; justify-content: center; align-items: center;">
    <a href="https://aijs-code-editor-user-content.web.app/Jt0mD7CW0uQHkOj4GzIUIHLkc4h2/Projects/P5_WebCloud/index.html" target="_blank">
      <button style="margin: 0;">P5.js</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/PzAJrh2a3" target="_blank">
      <button style="margin: 0;">Three.js</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/O9QSgf-IM" target="_blank">
      <button style="margin: 0;">WebGL</button>
    </a>
</div>
<hr>
<h4 id="benchmark-result">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/comparison.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="p5-js">P5.JS</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/P5_500.jpeg" alt="500 points" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<!-- <table> -->
<!-- <thead> -->
<!-- <tr> -->
<!-- <th class="width-auto"> -->
<!-- Points -->
<!-- </th> -->
<!-- <th class="width-auto"> -->
<!-- FPS -->
<!-- </th> -->
<!-- </tr> -->
<!-- </thead> -->
<!-- <tbody> -->
<!--   <tr> -->
<!--     <td> -->
<!--       500 -->
<!--     </td> -->
<!--     <td> -->
<!--         87.86 -->
<!--     </td> -->
<!--   </tr> -->
<!--   <tr> -->
<!--     <td> -->
<!--       1000 -->
<!--     </td> -->
<!--     <td> -->
<!--         54.01 -->
<!--     </td> -->
<!--   </tr> -->
<!--   <tr> -->
<!--     <td> -->
<!--       1500 -->
<!--     </td> -->
<!--     <td> -->
<!--        39.93.00 -->
<!--     </td> -->
<!--   </tr> -->
<!--     <tr> -->
<!--      <td>2000</td> -->
<!--      <td> -->
<!--         31.19 -->
<!--      </td> -->
<!--    </tr> -->
<!--    <tr> -->
<!--       <td> 2500</td> -->
<!--       <td> -->
<!--         25.80 -->
<!--       </td> -->
<!--     </tr> -->
<!--   </tbody> -->
<!-- </table> -->
<h4 id="three-js">THREE.JS</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/Three_500.jpeg" alt="threejs" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<!-- <table> -->
<!--   <thead> -->
<!--   <tr> -->
<!--   <th class="width-auto"> -->
<!--   Points -->
<!--   </th> -->
<!--   <th class="width-auto"> -->
<!--   FPS -->
<!--   </th> -->
<!--   </tr> -->
<!--   </thead> -->
<!--   <tbody> -->
<!--   <tr> -->
<!--     <td> -->
<!--       1000 -->
<!--     </td> -->
<!--     <td> -->
<!--        133.67 -->
<!--     </td> -->
<!--   </tr> -->
<!--   <tr> -->
<!--     <td> -->
<!--       1500 -->
<!--     </td> -->
<!--     <td> -->
<!--       57.92 -->
<!--     </td> -->
<!--   </tr> -->
<!--  <tr> -->
<!--     <td> -->
<!--       2000 -->
<!--     </td> -->
<!--     <td> -->
<!--         84.7 -->
<!--     </td> -->
<!--   </tr> -->
<!--    <tr> -->
<!--       <td> 2500</td> -->
<!--       <td> -->
<!--           55.62 -->
<!--       </td> -->
<!--     </tr> -->
<!--    </tr> -->
<!-- </tbody> -->
<!-- </table> -->
<h4 id="webgl">WEBGL</h4>
<!-- 
  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/WebGL_1000.jpeg" alt="webgl" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

 -->
<!-- <table> -->
<!--   <thead> -->
<!--     <tr> -->
<!--       <th class="width-auto"> -->
<!--         Points -->
<!--       </th> -->
<!--       <th class="width-auto"> -->
<!--         FPS -->
<!--       </th> -->
<!--     </tr> -->
<!--   </thead> -->
<!--   <tbody> -->
<!--     <tr> -->
<!--       <td> -->
<!--         1,000 -->
<!--       </td> -->
<!--       <td> -->
<!--           144 -->
<!--       </td> -->
<!--     </tr> -->
<!--     <tr> -->
<!--       <td> -->
<!--         10,000 -->
<!--       </td> -->
<!--       <td> -->
<!--           148 -->
<!--       </td> -->
<!--     </tr> -->
<!---->
<!--    <tr> -->
<!--       <td> -->
<!--         100,000 -->
<!--       </td> -->
<!--       <td> -->
<!--            147 -->
<!--       </td> -->
<!--     </tr> -->
<!--      <tr> -->
<!--         <td> 1,000,000</td> -->
<!--         <td> -->
<!--             55 -->
<!--         </td> -->
<!--       </tr> -->
<!--       <tr> -->
<!--        <td>10,000,000</td> -->
<!--        <td> -->
<!--             5 -->
<!--        </td> -->
<!--      </tr> -->
<!--   </tbody> -->
<!-- </table> -->
<!-- <hr> -->
<h4 id="conclusions">CONCLUSIONS</h4>
<p>
Each tool offers distinct advantages:
<ul class="incremental">
<li> Pure WebGL provides maximum flexibility at the cost of complexity.</li>
<li> P5.js is great for rapid prototyping and simpler projects.</li>
<li> Three.js strikes an effective balance, making it ideal for robust, production-ready applications.</li>
</ul>
</p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://jujpenabe.github.io/blog/p5retainedmodevsthreejs/">P5 retained mode vs Threejs</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-02-10
        </span>

    </div>

    


                    <div class="post-content">
            <table class="header">
 <tr>
    <td colspan="2" rowspan="2" class="width-auto">
      <h2 class="title">P5 retained mode vs Three.js</h2>
      <span class="subtitle">A WebGL benchmark of popular 3D web frameworks</span>
    </td>
    <th>Version</th>
    <td class="width-min">v0.1.0</td>
  </tr>
  <tr>
    <th>Updated</th>
    <td class="width-min"><time style="white-space: pre;">2025-03-10</time></td>
  </tr>
  <tr>
    <th class="width-min">Author</th>
    <td class="width-auto"><a href="https://mainpage.me/catblue44"><cite> Juan José Peña Becerra
</cite></a></td>
    <th class="width-min">License</th>
    <td>MIT</td>
  </tr>
</table>
<h4 id="methodology">METHODOLOGY</h4>
<p>To compare different rendering methods, a series of tests were conducted to evaluate performance in terms of rendering speed and responsiveness. Each test instantiated the same point cloud, represented as ellipses with 32 points by default. The only difference between the experiments was the rendering approach used:
<ul>
<li>p5.js - Immediate Mode: Each frame, all points are redrawn from scratch using procedural rendering.</li>
<li>p5.js - Retained Mode: Points are stored as objects and only updated when necessary, reducing redundant computations.</li>
<li>Three.js - BufferGeometry: Points are stored in a single geometry buffer, minimizing draw calls and improving performance compared to immediate mode.</li>
<li>Three.js - InstancedMesh: Instead of creating individual objects, a single mesh instance is reused multiple times, further optimizing rendering by leveraging GPU instancing.</li>
</ul>
<p>Each test was executed under the same conditions, measuring frame rate, CPU usage, and responsiveness to user interaction.</p>
</p>Explore the interactive sketches for each tool using the links below:
<hr>
<div class="button-container" style="display: flex; gap: 10px; justify-content: center; align-items: center;">
    <a href="https://editor.p5js.org/jujpenabe/full/-HC2R1oYt" target="_blank">
      <button style="margin: 0;">P5 immediate mode</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/PzAJrh2a3" target="_blank">
      <button style="margin: 0;">P5 retained mode</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/uaWCrVlPH" target="_blank">
      <button style="margin: 0;">Three.js Buffer geometry</button>
    </a>
    <a href="https://editor.p5js.org/jujpenabe/full/F10ioEqie" target="_blank">
      <button style="margin: 0;">Three.js Instanced Mesh</button>
    </a>
</div>
<hr>
<h4 id="p5-js-immediate-vs-retained-mode">P5.JS IMMEDIATE VS RETAINED MODE</h4>
<p>P5.js API provides two modes for rendering:  <a href="https://p5js.org/contribute/webgl_mode_architecture/#rendering-shapes-immediate-and-retained-modes." target="_blank">Immediate and Retained Modes</a>.</p>
<p>p5.js - Immediate Mode: In this approach, each frame is redrawn from scratch, meaning all shapes are re-rendered in every rendering cycle. This method is straightforward to implement but can become inefficient as scene complexity increases.</p>
<p>In the draw() method we use beginShape and endShape to create a series of vertices that define the shape of the object.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#65737e;">// Using immediate mode
</span><span style="color:#8fa1b3;">beginShape</span><span>(</span><span style="color:#bf616a;">TRIANGLE_FAN</span><span>);
</span><span>
</span><span style="color:#65737e;">// Center point
</span><span style="color:#8fa1b3;">vertex</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span style="color:#65737e;">// Draw points around ellipse
</span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">segments </span><span>= </span><span style="color:#d08770;">32</span><span>;
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">angle </span><span>= </span><span style="color:#8fa1b3;">map</span><span>(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">segments</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">TWO_PI</span><span>);
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">x </span><span>= </span><span style="color:#8fa1b3;">cos</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">20</span><span>;
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">y </span><span>= </span><span style="color:#8fa1b3;">sin</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">10</span><span>;
</span><span>  </span><span style="color:#8fa1b3;">vertex</span><span>(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>}
</span><span>
</span><span style="color:#8fa1b3;">endShape</span><span>();
</span></code></pre>
<p>p5.js - Retained Mode using p5.Geometry: While p5.js doesn't offer a native retained mode, you can simulate this behavior using the p5.Geometry class. This class allows you to create and store complex 3D geometries that can be rendered more efficiently. By constructing the geometry once and then drawing it as needed, you reduce redundant drawing operations, enhancing performance in complex scenes.</p>
<p>In the setup() method, we create a p5.Geometry object and store it in a variable called <code>ellipseGeom</code>.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">ellipseGeom</span><span>;
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">setup</span><span>() {
</span><span>
</span><span style="color:#65737e;">// Rest of setup() code
</span><span>
</span><span style="color:#65737e;">// Create retained mode geometry (just once)
</span><span>  </span><span style="color:#bf616a;">ellipseGeom </span><span>= </span><span style="color:#8fa1b3;">buildEllipseGeometry</span><span>();
</span><span>}
</span></code></pre>
<p>We build the geometry similar to how we build a shape in immediate mode. and return it as a p5.Geometry object.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">buildEllipseGeometry</span><span>() {
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">ellipse </span><span>= new p5.Geometry();
</span><span>
</span><span>  </span><span style="color:#65737e;">// Center point
</span><span>  </span><span style="color:#bf616a;">ellipse</span><span>.</span><span style="color:#bf616a;">vertices</span><span>.</span><span style="color:#96b5b4;">push</span><span>(new p5.Vector(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>));
</span><span>
</span><span>  </span><span style="color:#65737e;">// Draw points around ellipse
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">segments </span><span>= </span><span style="color:#d08770;">32</span><span>;
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">angle </span><span>= </span><span style="color:#8fa1b3;">map</span><span>(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">segments</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">TWO_PI</span><span>);
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">x </span><span>= </span><span style="color:#8fa1b3;">cos</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">20</span><span>;
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">y </span><span>= </span><span style="color:#8fa1b3;">sin</span><span>(</span><span style="color:#bf616a;">angle</span><span>) * </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#bf616a;">geometry</span><span>.</span><span style="color:#bf616a;">vertices</span><span>.</span><span style="color:#96b5b4;">push</span><span>(new p5.Vector(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#d08770;">0</span><span>));
</span><span>  }
</span><span>  
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">segments</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>    </span><span style="color:#bf616a;">ellipse</span><span>.</span><span style="color:#bf616a;">faces</span><span>.</span><span style="color:#96b5b4;">push</span><span>([</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#bf616a;">i </span><span>+ </span><span style="color:#d08770;">1</span><span>]);
</span><span>  }
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">ellipse</span><span>;
</span><span>}
</span></code></pre>
<p>In the draw() method, we use the p5.Geometry object to draw the ellipse.</p>
<pre data-lang="javascript" style="background-color:#2b303b;color:#c0c5ce;" class="language-javascript "><code class="language-javascript" data-lang="javascript"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">draw</span><span>() {
</span><span>  </span><span style="color:#8fa1b3;">background</span><span>(</span><span style="color:#d08770;">0</span><span>);
</span><span>  
</span><span>  </span><span style="color:#65737e;">// Draw the ellipse
</span><span>  </span><span style="color:#8fa1b3;">model</span><span>(</span><span style="color:#bf616a;">ellipseGeom</span><span>);
</span><span>}
</span></code></pre>
<h4 id="benchmark-result">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/p5ImmediateVsRetained.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="threejs-buffer-geometry-vs-instanced-mesh">Threejs Buffer Geometry vs Instanced Mesh</h4>
<p>Three.js is more especialized in rendering 3D scenes. It offers a wide range of features and tools for creating and manipulating 3D objects. It provides different methods for rendering complex 3D scenes, including BufferGeometry, InstancedMesh, and InstancedBufferGeometry.</p>
<p>BufferGeometry is a low-level API that provides direct access to GPU buffers. It offers fine-grained control over vertex data and can be used to create complex 3D scenes.</p>
<h4 id="benchmark-result-1">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/threejsBufferGeometryVsInstancedMesh.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="p5-js-retained-mode-vs-three-js-buffer-geometry">P5.js retained mode vs three.js buffer geometry</h4>
<p>p5 retained mode uses p5.Geometry to simulate retained mode. You build the geometry once and reuse it for rendering, which reduces redundant drawing. However, it doesn't leverage full GPU-level optimizations.</p>
<p>A native, highly optimized solution that uses typed arrays to store vertex data. It offers better performance and fine-grained control for complex 3D scenes.</p>
<h4 id="benchmark-result-2">BENCHMARK RESULT</h4>

  
  
    
    
  
  <img src="https://jujpenabe.github.io/../blog/p5RetainedModeVSThreejsBufferGeometry.jpg" alt="comparison" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<h4 id="future-work">Future Work</h4>
<ul>
<li>investigate why p5.js's retained mode using p5.Geometry underperforms compared to Three.js's BufferGeometry. By benchmarking these methods, we can identify specific inefficiencies in the retained mode approach. Additionally, exploring alternative techniques such as instancedMesh and instancedBufferGeometry may offer further performance improvements. Evaluating frameworks that leverage WebGPU could also uncover new strategies for optimizing complex 3D rendering workflows.</li>
</ul>
<h4 id="conclusions">CONCLUSIONS</h4>
<p>
Each tool offers distinct advantages:
<ul class="incremental">
<li> P5.js is great for rapid prototyping and simpler projects. But it doesn't leverage full GPU-level optimizations.</li>
<li> Three.js strikes an effective balance, making it ideal for robust, production-ready WEB applications.</li>
</ul>
</p>

        </div>

                </div>
            <div class="pagination">
                <div class="pagination__buttons"></div>
            </div>
        </div>
        
    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user">&copy; 2025 Juan José Peña Becerra&nbsp;<b>Universidad Nacional de Colombia</b></div>
            </div>
    </footer>
    

</div>
</body>

</html>
